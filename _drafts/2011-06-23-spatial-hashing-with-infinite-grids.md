---
layout: post
title: Spatial Hashing with Infinite Grids
oneliner: Set grid flux to maximum!
type: post
categories:
  - JavaScript
image:
tags:
  - JavaScript
  - Physics
---

Or, how I learned to use spatial hashing to reduce the number of collision checks!

I’ve been working on a JavaScript physics engine for a while. It uses a point-mass-based approach. When it’s more done than it is now (notice how ambiguous that was…), I’ll show it to… somebody. Anywho, I reached a limit for collision detection. I want to be able to have large numbers of particles and bodies in the world, and brute force checking of every object with every other just won’t cut it.

There are two ways, that I know of, to handle collision detection:

Brute force. This technique has you iterating through every single object in the world, and testing that object against every other object in the world. This works well, but only for a limited number of objects. The problem is that every object you add to the simulation does not add just one more check, but is instead exponential (basically every permutation). For example, if you have 4 objects, A, B, C, and D, you will need to test A vs B, A vs C, A vs D, B vs C, B vs D, and C vs D, for a total of 6 pair tests. No big deal, right? So let’s say you add one more object, E, for a total of 7 objects. That adds A vs E, B vs E, C vs E, and D vs E to the list of pairs to test. Adding one object added 4 more checks… and it just gets worse: for 100 objects, 4950 pairs will need to be tested*!
Spatial partitioning. Using some sort of structure, the space is divided up, and objects are registered to a specific area. Then, queries are performed on the structure to determine the number of collisions. This reduces the total number of pairs that need to be tested by first separating objects that are far away without doing an actual distance calculation.
*To determine the number of pairs generated by the brute force method, I used the following two functions:

function factorial(x){
	if(x < 2){ return 1; }
	return (x * factorial(x-1));
}

function combos(pool, kids){
	return factorial(pool) / (factorial(pool - kids) * factorial(kids));
}

The number of pairs for 100 objects: combos(100, 2) = 4950.